<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>JavaScript中的数组拷贝 | 胡椒灰のBlog</title>
  <meta name="author" content="PepperHxH">
  
  <meta name="description" content="前沿
JavaScript中的基本类型和引用类型：


基本类型基本类型值储存在栈内存中

string
number
boolean
undefined
null


引用类型当声明一个对象时，对象的声明变量名被存储在了栈内存中，并保存了对象在堆内存中的地址值，而在堆内存中保存的是对象的值。对象储存在对内存中，而我们无法直接操作对内存，只能通过占内存中的地址值获取堆内存中的值。

Object
Array
Function




基本类型和引用类型的区别：


基本类型的值是不可变的：基本类型的值修改后，相当于直接重新赋值了，而引用类型值是对原来的值进行增删改查。
不能给基本类型添加属性和方法
基本类型的比较是值的比较，而引用类型值得比较是引用地址的比较"> 
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JavaScript中的数组拷贝"/>
  <meta property="og:site_name" content="胡椒灰のBlog"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 4.2.1"></head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">胡椒灰のBlog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> JavaScript中的数组拷贝</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><ol>
<li>JavaScript中的基本类型和引用类型：</li>
</ol>
<ul>
<li><p>基本类型<br>基本类型值储存在栈内存中</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>undefined</li>
<li>null</li>
</ul>
</li>
<li><p>引用类型<br>当声明一个对象时，对象的声明变量名被存储在了栈内存中，并保存了对象在堆内存中的地址值，而在堆内存中保存的是对象的值。<br>对象储存在对内存中，而我们无法直接操作对内存，只能通过占内存中的地址值获取堆内存中的值。</p>
<ul>
<li>Object</li>
<li>Array</li>
<li>Function</li>
</ul>
</li>
</ul>
<ol start="2">
<li>基本类型和引用类型的区别：</li>
</ol>
<ul>
<li>基本类型的值是不可变的：基本类型的值修改后，相当于直接重新赋值了，而引用类型值是对原来的值进行增删改查。</li>
<li>不能给基本类型添加属性和方法</li>
<li>基本类型的比较是值的比较，而引用类型值得比较是引用地址的比较<a id="more"></a>

</li>
</ul>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h3 id="1-什么是浅拷贝？"><a href="#1-什么是浅拷贝？" class="headerlink" title="1. 什么是浅拷贝？"></a>1. 什么是浅拷贝？</h3><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<h3 id="2-浅拷贝使用场景"><a href="#2-浅拷贝使用场景" class="headerlink" title="2. 浅拷贝使用场景"></a>2. 浅拷贝使用场景</h3><h4 id="2-1-Object-assign"><a href="#2-1-Object-assign" class="headerlink" title="2.1 Object.assign()"></a>2.1 Object.assign()</h4><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// saucxs</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">"saucxs"</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">"You Don't Know JS"</span>,</span><br><span class="line">        price: <span class="string">"45"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: "saucxs",</span></span><br><span class="line"><span class="comment">// 	book: &#123;title: "You Don't Know JS", price: "45"&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">"change"</span>;</span><br><span class="line">a.book.price = <span class="string">"55"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: "change",</span></span><br><span class="line"><span class="comment">// 	book: &#123;title: "You Don't Know JS", price: "55"&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 	name: "saucxs",</span></span><br><span class="line"><span class="comment">// 	book: &#123;title: "You Don't Know JS", price: "55"&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 <code>book</code> 时，对象 b 相应的位置也发生了变化。</p>
<h4 id="2-2-扩展运算符spread-…"><a href="#2-2-扩展运算符spread-…" class="headerlink" title="2.2 扩展运算符spread(…)"></a>2.2 扩展运算符spread(…)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    name: &quot;saucxs&quot;,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: &quot;You Don&#39;t Know JS&quot;,</span><br><span class="line">        price: &quot;45&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#123;...a&#125;;</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; 	book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">a.name &#x3D; &quot;change&quot;;</span><br><span class="line">a.book.price &#x3D; &quot;55&quot;;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;change&quot;,</span><br><span class="line">&#x2F;&#x2F; 	book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; 	book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-Array-prototype-slice方法"><a href="#2-3-Array-prototype-slice方法" class="headerlink" title="2.3 Array.prototype.slice方法"></a>2.3 Array.prototype.slice方法</h4><p>slice不会改变原数组，<code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code>和 <code>end</code>（不包括<code>end</code>）决定的原数组的<strong>浅拷贝</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; [0, &quot;1&quot;, [2, 3]];</span><br><span class="line">let b &#x3D; a.slice(1);</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; [&quot;1&quot;, [2, 3]]</span><br><span class="line"></span><br><span class="line">a[1] &#x3D; &quot;99&quot;;</span><br><span class="line">a[2][0] &#x3D; 4;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; [0, &quot;99&quot;, [4, 3]]</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F;  [&quot;1&quot;, [4, 3]]</span><br></pre></td></tr></table></figure>
<p>可以看出，改变 <code>a[1]</code> 之后 <code>b[0]</code> 的值并没有发生变化，但改变 <code>a[2][0]</code> 之后，相应的 <code>b[1][0]</code> 的值也发生变化。<br>说明 <code>slice()</code> 方法是浅拷贝，相应的还有<code>concat</code>等，在工作中面对复杂数组结构要额外注意。</p>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h3 id="1-什么是深拷贝？"><a href="#1-什么是深拷贝？" class="headerlink" title="1. 什么是深拷贝？"></a>1. 什么是深拷贝？</h3><p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p>
<h3 id="2-使用深拷贝的场景"><a href="#2-使用深拷贝的场景" class="headerlink" title="2. 使用深拷贝的场景"></a>2. 使用深拷贝的场景</h3><h4 id="2-1-JSON-parse-JSON-stringify-object"><a href="#2-1-JSON-parse-JSON-stringify-object" class="headerlink" title="2.1 JSON.parse(JSON.stringify(object))"></a>2.1 JSON.parse(JSON.stringify(object))</h4><p>JSON.stringify()将JS对象序列化为JSON字符串<br>JSON.parse()将JSON字符串解析为原生JS值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    name: &quot;saucxs&quot;,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: &quot;You Don&#39;t Know JS&quot;,</span><br><span class="line">        price: &quot;45&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(a));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; 	book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">a.name &#x3D; &quot;change&quot;;</span><br><span class="line">a.book.price &#x3D; &quot;55&quot;;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;change&quot;,</span><br><span class="line">&#x2F;&#x2F; 	book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; 	book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>
<p>完全改变变量 a 之后对 b 没有任何影响，这就是深拷贝的魔力。<br>我们看下对数组深拷贝效果如何。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; [0, &quot;1&quot;, [2, 3]];</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify( a.slice(1) ));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; [&quot;1&quot;, [2, 3]]</span><br><span class="line"></span><br><span class="line">a[1] &#x3D; &quot;99&quot;;</span><br><span class="line">a[2][0] &#x3D; 4;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; [0, &quot;99&quot;, [4, 3]]</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F;  [&quot;1&quot;, [2, 3]]</span><br></pre></td></tr></table></figure>
<p>对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组。<br>但是该方法有以下几个问题：<br>（1）会忽略 <code>undefined</code><br>（2）会忽略 <code>symbol</code><br>（3）不能序列化函数<br>（4）不能解决循环引用的对象<br>（5）不能正确处理<code>new Date()</code><br>（6）不能处理正则<br>其中（1）（2）（3） <code>undefined</code>、<code>symbol</code> 和函数这三种情况，会直接忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &#39;saucxs&#39;,</span><br><span class="line">    a: undefined,</span><br><span class="line">    b: Symbol(&#39;saucxs&#39;),</span><br><span class="line">    c: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; 	name: &quot;saucxs&quot;, </span><br><span class="line">&#x2F;&#x2F; 	a: undefined, </span><br><span class="line">&#x2F;&#x2F;  b: Symbol(saucxs), </span><br><span class="line">&#x2F;&#x2F;  c: ƒ ()</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;name: &quot;saucxs&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>其中（4）循环引用会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: 2,</span><br><span class="line">   		d: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a &#x3D; obj.b;</span><br><span class="line">obj.b.c &#x3D; obj.a;</span><br><span class="line"></span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: Converting circular structure to JSON</span><br></pre></td></tr></table></figure>
<p>其中(5)* <code>new Date</code> 情况下，转换结果不正确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">new Date();</span><br><span class="line">&#x2F;&#x2F; Mon Dec 24 2018 10:59:14 GMT+0800 (China Standard Time)</span><br><span class="line"></span><br><span class="line">JSON.stringify(new Date());</span><br><span class="line">&#x2F;&#x2F; &quot;&quot;2018-12-24T02:59:25.776Z&quot;&quot;</span><br><span class="line"></span><br><span class="line">JSON.parse(JSON.stringify(new Date()));</span><br><span class="line">&#x2F;&#x2F; &quot;2018-12-24T02:59:41.523Z&quot;</span><br></pre></td></tr></table></figure>
<p>解决方法转成字符串或者时间戳就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let date &#x3D; (new Date()).valueOf();</span><br><span class="line">&#x2F;&#x2F; 1545620645915</span><br><span class="line"></span><br><span class="line">JSON.stringify(date);</span><br><span class="line">&#x2F;&#x2F; &quot;1545620673267&quot;</span><br><span class="line"></span><br><span class="line">JSON.parse(JSON.stringify(date));</span><br><span class="line">&#x2F;&#x2F; 1545620658688</span><br></pre></td></tr></table></figure>
<p>其中（6）正则情况下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &quot;saucxs&quot;,</span><br><span class="line">    a: &#x2F;&#39;123&#39;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);</span><br><span class="line">&#x2F;&#x2F; &#123;name: &quot;saucxs&quot;, a: &#x2F;&#39;123&#39;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;name: &quot;saucxs&quot;, a: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-手动实现深拷贝"><a href="#2-2-手动实现深拷贝" class="headerlink" title="2.2 手动实现深拷贝"></a>2.2 手动实现深拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: 2</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">   a: obj1.a,</span><br><span class="line">   b: obj1.b</span><br><span class="line">&#125;</span><br><span class="line">obj2.a &#x3D; 3;</span><br><span class="line">alert(obj1.a); &#x2F;&#x2F; 1</span><br><span class="line">alert(obj2.a); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">   a: &#123;</span><br><span class="line">     b: 2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">   a: obj1.a</span><br><span class="line">&#125;</span><br><span class="line">obj2.a.b &#x3D; 3;</span><br><span class="line">console.log(obj1.a.b); &#x2F;&#x2F; 3</span><br><span class="line">console.log(obj2.a.b); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<h4 id="2-3-递归实现深拷贝"><a href="#2-3-递归实现深拷贝" class="headerlink" title="2.3 递归实现深拷贝"></a>2.3 递归实现深拷贝</h4><h4 id="2-4-jquery实现深拷贝"><a href="#2-4-jquery实现深拷贝" class="headerlink" title="2.4 jquery实现深拷贝"></a>2.4 jquery实现深拷贝</h4><p>jquery 提供一个$.extend可以用来做深拷贝；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var $ &#x3D; require(&#39;jquery&#39;);</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: &#123;</span><br><span class="line">     f: &#123;</span><br><span class="line">       g: 1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 &#x3D; $.extend(true, &#123;&#125;, obj1);</span><br><span class="line">console.log(obj1.b.f &#x3D;&#x3D;&#x3D; obj2.b.f);  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h1 id="数组拷贝方法"><a href="#数组拷贝方法" class="headerlink" title="数组拷贝方法"></a>数组拷贝方法</h1><p>注意：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p>
<h4 id="1-扩展运算符（浅拷贝）"><a href="#1-扩展运算符（浅拷贝）" class="headerlink" title="1. 扩展运算符（浅拷贝）"></a>1. 扩展运算符（浅拷贝）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; [...numbers];</span><br><span class="line">这个方法不能有效的拷贝多维数组。数组&#x2F;对象值的拷贝是通过引用而不是值复制。</span><br><span class="line">&#x2F;&#x2F; numbersCopy.push(4);</span><br><span class="line">console.log(numbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] and [1, 2, 3, 4]</span><br><span class="line">&#x2F;&#x2F; 只修改了我们希望修改的，原数组不受影响</span><br><span class="line">&#x2F;&#x2F; nestedNumbers &#x3D; [[1], [2]];</span><br><span class="line">numbersCopy &#x3D; [...nestedNumbers];</span><br><span class="line">numbersCopy[0].push(300);</span><br><span class="line">console.log(nestedNumbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; 由于公用引用，所以两个数组都被修改了，这是我们不希望的</span><br></pre></td></tr></table></figure>

<h4 id="2-for-循环、while-循环（浅拷贝）"><a href="#2-for-循环、while-循环（浅拷贝）" class="headerlink" title="2. for()循环、while()循环（浅拷贝）"></a>2. for()循环、while()循环（浅拷贝）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; [];</span><br><span class="line">for (i &#x3D; 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line"> numbersCopy[i] &#x3D; numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">这个方法不能有效的拷贝多维数组。因为我们使用的是&#x3D;运算符，它在处理数组&#x2F;对象值的拷贝时通过引用而不是值复制。</span><br><span class="line">&#x2F;&#x2F; numbersCopy.push(4);</span><br><span class="line">console.log(numbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] and [1, 2, 3, 4]</span><br><span class="line">&#x2F;&#x2F; nestedNumbers &#x3D; [[1], [2]];</span><br><span class="line">numbersCopy &#x3D; [];</span><br><span class="line">for (i &#x3D; 0; i &lt; nestedNumbers.length; i++) &#123;</span><br><span class="line"> numbersCopy[i] &#x3D; nestedNumbers[i];</span><br><span class="line">&#125;</span><br><span class="line">numbersCopy[0].push(300);</span><br><span class="line">console.log(nestedNumbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; 由于公用引用，所以两个数组都被修改了，这是我们不希望的</span><br></pre></td></tr></table></figure>
<h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while()循环"></a>while()循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; [];</span><br><span class="line">i &#x3D; -1;</span><br><span class="line">while (++i &lt; numbers.length) &#123;</span><br><span class="line"> numbersCopy[i] &#x3D; numbers[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Array-map（浅拷贝）"><a href="#3-Array-map（浅拷贝）" class="headerlink" title="3. Array.map（浅拷贝）"></a>3. Array.map（浅拷贝）</h4><p>上面的for和while都是很“古老”的方式，让我们继续回到当前，我们会发现map方法。map源于数学，是将一个集合转换成另一种集合，同时保留结构的概念。<br>在英语中，它意味着Array.map 每次返回相同长度的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">double &#x3D; (x) &#x3D;&gt; x * 2;</span><br><span class="line">numbers.map(double);</span><br></pre></td></tr></table></figure>
<p>当我们使用map方法时，需要给出一个callback函数用于处理当前的数组，并返回一个新的数组元素。<br>和拷贝数组有什么关系呢？<br>当我们想要复制一个数组的时候，只需要在map的callback函数中直接返回原数组的元素即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; numbers.map((x) &#x3D;&gt; x);</span><br></pre></td></tr></table></figure>
<p>如果你想更数学化一点，(x) =&gt; x叫做恒等式。它返回给定的任何参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">identity &#x3D; (x) &#x3D;&gt; x;</span><br><span class="line">numbers.map(identity);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>同样的，处理对象和数组的时候是引用而不是值复制。</p>
<h4 id="4-Array-filter（浅拷贝）"><a href="#4-Array-filter（浅拷贝）" class="headerlink" title="4. Array.filter（浅拷贝）"></a>4. Array.filter（浅拷贝）</h4><p>Array.filter方法同样会返回一个新数组，但是并不一定是返回同样长度的，这和我们的过滤条件有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].filter((x) &#x3D;&gt; x % 2 &#x3D;&#x3D;&#x3D; 0)</span><br><span class="line">&#x2F;&#x2F; [2]</span><br></pre></td></tr></table></figure>
<p>当我们的过滤条件总是true时，就可以用来实现拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; numbers.filter(() &#x3D;&gt; true);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>同样的，处理对象和数组的时候是引用而不是值复制。</p>
<h4 id="5-Array-reduce（浅拷贝）"><a href="#5-Array-reduce（浅拷贝）" class="headerlink" title="5. Array.reduce（浅拷贝）"></a>5. Array.reduce（浅拷贝）</h4><p>其实用reduce来拷贝数组并没有展示出它的实际功能，但是我们还是要将其能够拷贝数组的能力说一下的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; numbers.reduce((newArray, element) &#x3D;&gt; &#123;</span><br><span class="line"> newArray.push(element);</span><br><span class="line"> return newArray;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>
<p>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数，将其结果汇总为单个返回值。<br>上面我们的例子中初始值是一个空数组，我们在遍历原数组的时候来填充这个空数组。该数组必须要从下一个迭代函数的执行后被返回出来。<br>同样的，处理对象和数组的时候是引用而不是值复制。</p>
<h4 id="6-Array-slice（浅拷贝）"><a href="#6-Array-slice（浅拷贝）" class="headerlink" title="6. Array.slice（浅拷贝）"></a>6. Array.slice（浅拷贝）</h4><p>slice 方法根据我们指定的start、end的index从原数组中返回一个浅拷贝的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].slice(0, 3);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">&#x2F;&#x2F; Starts at index 0, stops at index 3</span><br><span class="line">&#x2F;&#x2F; 当不给定参数时，就返回了原数组的拷贝</span><br><span class="line">numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">numbersCopy &#x3D; numbers.slice();</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>同样的，处理对象和数组的时候是引用而不是值复制。</p>
<h4 id="7-JSON-parse-JSON-stringify-object-（深拷贝）"><a href="#7-JSON-parse-JSON-stringify-object-（深拷贝）" class="headerlink" title="7. JSON.parse(JSON.stringify(object))（深拷贝）"></a>7. JSON.parse(JSON.stringify(object))（深拷贝）</h4><h4 id="8、Array-concat（浅拷贝）"><a href="#8、Array-concat（浅拷贝）" class="headerlink" title="8、Array.concat（浅拷贝）"></a>8、Array.concat（浅拷贝）</h4><p>concat将数组与值或其他数组进行组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].concat(4); &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">[1, 2, 3].concat([4, 5]); &#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>如果我们不指定参数或者提供一个空数组作为参数，就可以进行浅拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].concat(); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">[1, 2, 3].concat([]); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>同样的，处理对象和数组的时候是引用而不是值复制。</p>
<h4 id="9、Array-from（浅拷贝）"><a href="#9、Array-from（浅拷贝）" class="headerlink" title="9、Array.from（浅拷贝）"></a>9、Array.from（浅拷贝）</h4><p>可以将任何可迭代对象转换为数组。给一个数组返回一个浅拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from(&#39;foo&#39;))</span><br><span class="line">&#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span><br><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; Array.from(numbers)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>同样的，处理对象和数组的时候是引用而不是值复制。</p>
<h1 id="笔记参考链接："><a href="#笔记参考链接：" class="headerlink" title="笔记参考链接："></a>笔记参考链接：</h1><ol>
<li><a href="https://www.cnblogs.com/chengxs/p/10788442.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/10788442.html</a></li>
<li><a href="https://blog.csdn.net/luoandhuang/article/details/90258010" target="_blank" rel="noopener">https://blog.csdn.net/luoandhuang/article/details/90258010</a></li>
<li><a href="https://www.jb51.net/article/160063.htm" target="_blank" rel="noopener">https://www.jb51.net/article/160063.htm</a></li>
</ol>

	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/2019/12/09/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D/" class="leancloud-visitors view" data-flag-title="JavaScript中的数组拷贝">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/2019/12/20/Webpack脚手架搭建/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2019/12/03/JS中scrollTop()的浏览器兼容问题/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>

-->
	
		<section id="comments" class="comments">
			<style>
			.comments{margin:30px;padding:10px;background:rgb(0, 0, 0)}
			@media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#000}}
			</style>
			<div id="vcomment" class="comment"></div>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script src="https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
var valineConfig = {"enable":true,"appId":"xxx","appKey":"xxx","placeholder":"提交评论时留下邮箱收到回复后将自动通知","visitor":true,"avatar":"monsterid","requiredFields":["nick","mail"]}
valineConfig.el='#vcomment';
new Valine(valineConfig);
    // new Valine({
    //     el: '#vcomment',
    //     appId: "",
    //     appKey: "",
    //     placeholder: "提交评论时留下邮箱收到回复后将自动通知",
    //     avatar:"monsterid",
    //     visitor: "true",
    //     requiredFields: "nick,mail".split(','),
    // });
</script>

		</section>
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2019-12-09 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2020 PepperHxH's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
