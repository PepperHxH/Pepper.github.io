<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>React-Redux - 制作简易TodoList</title>
      <link href="/2020/08/04/React-Redux%20-%20%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93TodoList/"/>
      <url>/2020/08/04/React-Redux%20-%20%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93TodoList/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习react-redux做的一个todolist demo</p></blockquote><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a><code>Provider</code></h4><p>React-Redux提供<code>&lt;Provider/&gt;</code>组件，能够使整个App组件访问到Redux store中的数据</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code></h4><p>把组件和store连接起来</p><ul><li><code>mapStateToProps</code>: Extracting Data with mapStateToProps<br>connect的第一个参数</li></ul><ol><li>每次store state改变时都会调用它</li><li>接收store state数据，并返回当前组件所需数据对象</li></ol><ul><li><code>mapDispatchToProps</code>: Dispatching Actions with mapDispatchToProps<br>用dispath传递actions是唯一的改变state的方法<br>两种dispatch actions的方法：</li></ul><ol><li>直接使用props.dispatch</li><li>使用<code>mapDispatchToProps</code>参数，并将actions作为props传入子组件，调用到它时，会将actions dispatch到reducers处理数据</li></ol><h3 id="React-UI组件"><a href="#React-UI组件" class="headerlink" title="React UI组件"></a>React UI组件</h3><ul><li><code>TodoApp</code>: 应用程序的输入组件。它渲染出<code>AddTodo</code>，<code>TodoList</code>和<code>VisibilityFilters</code>组件。</li><li><code>AddTodo</code>: 允许用户在点击<code>Add Todo</code>按钮后，向todo list中加入一个新的待办项。</li><li><code>TodoList</code>: 渲染待办事项清单的组件。</li><li><code>Todo</code>: 渲染单个待办事项的组件。</li><li><code>VisibilityFilters</code>: 渲染一组简单的过滤器：<code>all</code>，<code>completed</code>和<code>incomplete</code>。</li><li><code>constants</code>: 保存常量数据。<br>最后<code>index</code>将应用程序呈现给DOM。</li></ul><h3 id="Redux-Store"><a href="#Redux-Store" class="headerlink" title="Redux Store"></a>Redux Store</h3><ul><li><code>Store</code><ul><li><code>todos</code>：标准化的todos的<code>reducer</code>。包含了byIds的待办项map对象结构，和一个包含了所有待办项id的allIds数组</li><li><code>visibilityFilters</code>：简单的字符串<code>all</code>, <code>completed</code>和 <code>incomplete</code>.</li></ul></li><li><code>Action Creators</code><ul><li><code>addTodo</code>：创建增添待办项的action。接收一个string变量content，返回ADD_TODO类型的action，以及一个payload对象（包含了自增的id和content属性）</li><li><code>toggleTodo</code>：创建一个切换待办项的action。只接收一个number类型的变量id，返回TOGGLE_TODO类型action以及仅含id属性的payload对象。</li><li><code>setFilter</code>：创建设置app当前过滤条件的action。接收一个string类型变量filter返回一个SET_FILTER类型action一集一个包含filter自身的payload对象。</li></ul></li><li><code>Reducers</code><ul><li><code>todos</code>:<ul><li>在接收到ADD_TODO action时，将id追加到allIds数组，并且更新byIds</li><li>在接收到TOGGLE_TODO action时，切换completed状态</li></ul></li><li><code>VisibilityFilters</code>：在接收到SET_FILTERaction 时负责更新VISIBILITY_FILTERS状态</li></ul></li><li><code>Action Types</code><br>  • 保存常量，以便复用</li><li><code>Selectores</code><ul><li><code>getTodoList</code>：从todos store中返回allIds列表</li><li><code>getTodoById</code>：通过id查询store中的todo项</li><li><code>getTodos</code>：接收allIds数组中的所有id，找到每一个对应的byIds中的todo，返回最终的todos数组</li><li><code>getTodosByVisibilityFilter</code>：根据筛选条件过滤todos</li></ul></li></ul><h3 id="Screenshots"><a href="#Screenshots" class="headerlink" title="Screenshots"></a>Screenshots</h3><p><img src="../images/screenshot1.jpg" alt="screenshot1"><br><img src="../images/screenshot2.jpg" alt="screenshot1"></p><h3 id="官方教程链接"><a href="#官方教程链接" class="headerlink" title="官方教程链接"></a>官方教程链接</h3><p><a href="https://react-redux.js.org/introduction/basic-tutorial" target="_blank" rel="noopener">https://react-redux.js.org/introduction/basic-tutorial</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack脚手架搭建</title>
      <link href="/2019/12/20/Webpack%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/12/20/Webpack%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="webpack-dev-server常用命令参数"><a href="#webpack-dev-server常用命令参数" class="headerlink" title="webpack-dev-server常用命令参数"></a>webpack-dev-server常用命令参数</h2><p>在项目的package.json文件的scripts命令中为webpack-dev-server传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --open</span><br></pre></td></tr></table></figure><p>可在执行npm run dev后自动打开浏览器页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --port 3000</span><br></pre></td></tr></table></figure><p>可将浏览器端口设置为3000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --hot</span><br></pre></td></tr></table></figure><p>每次保存只将更新过的代码部分打包成一个补丁  而不是重新生成一个包  且能实现页面的异步刷新</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的数组拷贝</title>
      <link href="/2019/12/09/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/12/09/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><ol><li>JavaScript中的基本类型和引用类型：</li></ol><ul><li><p>基本类型<br>基本类型值储存在栈内存中</p><ul><li>string</li><li>number</li><li>boolean</li><li>undefined</li><li>null</li></ul></li><li><p>引用类型<br>当声明一个对象时，对象的声明变量名被存储在了栈内存中，并保存了对象在堆内存中的地址值，而在堆内存中保存的是对象的值。<br>对象储存在对内存中，而我们无法直接操作对内存，只能通过占内存中的地址值获取堆内存中的值。</p><ul><li>Object</li><li>Array</li><li>Function</li></ul></li></ul><ol start="2"><li>基本类型和引用类型的区别：</li></ol><ul><li>基本类型的值是不可变的：基本类型的值修改后，相当于直接重新赋值了，而引用类型值是对原来的值进行增删改查。</li><li>不能给基本类型添加属性和方法</li><li>基本类型的比较是值的比较，而引用类型值得比较是引用地址的比较<a id="more"></a></li></ul><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h3 id="1-什么是浅拷贝？"><a href="#1-什么是浅拷贝？" class="headerlink" title="1. 什么是浅拷贝？"></a>1. 什么是浅拷贝？</h3><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><h3 id="2-浅拷贝使用场景"><a href="#2-浅拷贝使用场景" class="headerlink" title="2. 浅拷贝使用场景"></a>2. 浅拷贝使用场景</h3><h4 id="2-1-Object-assign"><a href="#2-1-Object-assign" class="headerlink" title="2.1 Object.assign()"></a>2.1 Object.assign()</h4><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// saucxs</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">"saucxs"</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">"You Don't Know JS"</span>,</span><br><span class="line">        price: <span class="string">"45"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: "saucxs",</span></span><br><span class="line"><span class="comment">// book: &#123;title: "You Don't Know JS", price: "45"&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">"change"</span>;</span><br><span class="line">a.book.price = <span class="string">"55"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: "change",</span></span><br><span class="line"><span class="comment">// book: &#123;title: "You Don't Know JS", price: "55"&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: "saucxs",</span></span><br><span class="line"><span class="comment">// book: &#123;title: "You Don't Know JS", price: "55"&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 <code>book</code> 时，对象 b 相应的位置也发生了变化。</p><h4 id="2-2-扩展运算符spread-…"><a href="#2-2-扩展运算符spread-…" class="headerlink" title="2.2 扩展运算符spread(…)"></a>2.2 扩展运算符spread(…)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    name: &quot;saucxs&quot;,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: &quot;You Don&#39;t Know JS&quot;,</span><br><span class="line">        price: &quot;45&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#123;...a&#125;;</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">a.name &#x3D; &quot;change&quot;;</span><br><span class="line">a.book.price &#x3D; &quot;55&quot;;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;change&quot;,</span><br><span class="line">&#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-Array-prototype-slice方法"><a href="#2-3-Array-prototype-slice方法" class="headerlink" title="2.3 Array.prototype.slice方法"></a>2.3 Array.prototype.slice方法</h4><p>slice不会改变原数组，<code>slice()</code> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code>和 <code>end</code>（不包括<code>end</code>）决定的原数组的<strong>浅拷贝</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; [0, &quot;1&quot;, [2, 3]];</span><br><span class="line">let b &#x3D; a.slice(1);</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; [&quot;1&quot;, [2, 3]]</span><br><span class="line"></span><br><span class="line">a[1] &#x3D; &quot;99&quot;;</span><br><span class="line">a[2][0] &#x3D; 4;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; [0, &quot;99&quot;, [4, 3]]</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F;  [&quot;1&quot;, [4, 3]]</span><br></pre></td></tr></table></figure><p>可以看出，改变 <code>a[1]</code> 之后 <code>b[0]</code> 的值并没有发生变化，但改变 <code>a[2][0]</code> 之后，相应的 <code>b[1][0]</code> 的值也发生变化。<br>说明 <code>slice()</code> 方法是浅拷贝，相应的还有<code>concat</code>等，在工作中面对复杂数组结构要额外注意。</p><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h3 id="1-什么是深拷贝？"><a href="#1-什么是深拷贝？" class="headerlink" title="1. 什么是深拷贝？"></a>1. 什么是深拷贝？</h3><p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。</p><h3 id="2-使用深拷贝的场景"><a href="#2-使用深拷贝的场景" class="headerlink" title="2. 使用深拷贝的场景"></a>2. 使用深拷贝的场景</h3><h4 id="2-1-JSON-parse-JSON-stringify-object"><a href="#2-1-JSON-parse-JSON-stringify-object" class="headerlink" title="2.1 JSON.parse(JSON.stringify(object))"></a>2.1 JSON.parse(JSON.stringify(object))</h4><p>JSON.stringify()将JS对象序列化为JSON字符串<br>JSON.parse()将JSON字符串解析为原生JS值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    name: &quot;saucxs&quot;,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: &quot;You Don&#39;t Know JS&quot;,</span><br><span class="line">        price: &quot;45&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(a));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">a.name &#x3D; &quot;change&quot;;</span><br><span class="line">a.book.price &#x3D; &quot;55&quot;;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;change&quot;,</span><br><span class="line">&#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;55&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125; </span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;saucxs&quot;,</span><br><span class="line">&#x2F;&#x2F; book: &#123;title: &quot;You Don&#39;t Know JS&quot;, price: &quot;45&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure><p>完全改变变量 a 之后对 b 没有任何影响，这就是深拷贝的魔力。<br>我们看下对数组深拷贝效果如何。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let a &#x3D; [0, &quot;1&quot;, [2, 3]];</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify( a.slice(1) ));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; [&quot;1&quot;, [2, 3]]</span><br><span class="line"></span><br><span class="line">a[1] &#x3D; &quot;99&quot;;</span><br><span class="line">a[2][0] &#x3D; 4;</span><br><span class="line">console.log(a);</span><br><span class="line">&#x2F;&#x2F; [0, &quot;99&quot;, [4, 3]]</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F;  [&quot;1&quot;, [2, 3]]</span><br></pre></td></tr></table></figure><p>对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组。<br>但是该方法有以下几个问题：<br>（1）会忽略 <code>undefined</code><br>（2）会忽略 <code>symbol</code><br>（3）不能序列化函数<br>（4）不能解决循环引用的对象<br>（5）不能正确处理<code>new Date()</code><br>（6）不能处理正则<br>其中（1）（2）（3） <code>undefined</code>、<code>symbol</code> 和函数这三种情况，会直接忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &#39;saucxs&#39;,</span><br><span class="line">    a: undefined,</span><br><span class="line">    b: Symbol(&#39;saucxs&#39;),</span><br><span class="line">    c: function() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);</span><br><span class="line">&#x2F;&#x2F; &#123;</span><br><span class="line">&#x2F;&#x2F; name: &quot;saucxs&quot;, </span><br><span class="line">&#x2F;&#x2F; a: undefined, </span><br><span class="line">&#x2F;&#x2F;  b: Symbol(saucxs), </span><br><span class="line">&#x2F;&#x2F;  c: ƒ ()</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;name: &quot;saucxs&quot;&#125;</span><br></pre></td></tr></table></figure><p>其中（4）循环引用会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: 2,</span><br><span class="line">   d: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a &#x3D; obj.b;</span><br><span class="line">obj.b.c &#x3D; obj.a;</span><br><span class="line"></span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: Converting circular structure to JSON</span><br></pre></td></tr></table></figure><p>其中(5)* <code>new Date</code> 情况下，转换结果不正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">new Date();</span><br><span class="line">&#x2F;&#x2F; Mon Dec 24 2018 10:59:14 GMT+0800 (China Standard Time)</span><br><span class="line"></span><br><span class="line">JSON.stringify(new Date());</span><br><span class="line">&#x2F;&#x2F; &quot;&quot;2018-12-24T02:59:25.776Z&quot;&quot;</span><br><span class="line"></span><br><span class="line">JSON.parse(JSON.stringify(new Date()));</span><br><span class="line">&#x2F;&#x2F; &quot;2018-12-24T02:59:41.523Z&quot;</span><br></pre></td></tr></table></figure><p>解决方法转成字符串或者时间戳就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let date &#x3D; (new Date()).valueOf();</span><br><span class="line">&#x2F;&#x2F; 1545620645915</span><br><span class="line"></span><br><span class="line">JSON.stringify(date);</span><br><span class="line">&#x2F;&#x2F; &quot;1545620673267&quot;</span><br><span class="line"></span><br><span class="line">JSON.parse(JSON.stringify(date));</span><br><span class="line">&#x2F;&#x2F; 1545620658688</span><br></pre></td></tr></table></figure><p>其中（6）正则情况下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; saucxs</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    name: &quot;saucxs&quot;,</span><br><span class="line">    a: &#x2F;&#39;123&#39;&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj);</span><br><span class="line">&#x2F;&#x2F; &#123;name: &quot;saucxs&quot;, a: &#x2F;&#39;123&#39;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(b);</span><br><span class="line">&#x2F;&#x2F; &#123;name: &quot;saucxs&quot;, a: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-手动实现深拷贝"><a href="#2-2-手动实现深拷贝" class="headerlink" title="2.2 手动实现深拷贝"></a>2.2 手动实现深拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: 2</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">   a: obj1.a,</span><br><span class="line">   b: obj1.b</span><br><span class="line">&#125;</span><br><span class="line">obj2.a &#x3D; 3;</span><br><span class="line">alert(obj1.a); &#x2F;&#x2F; 1</span><br><span class="line">alert(obj2.a); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let obj1 &#x3D; &#123;</span><br><span class="line">   a: &#123;</span><br><span class="line">     b: 2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let obj2 &#x3D; &#123;</span><br><span class="line">   a: obj1.a</span><br><span class="line">&#125;</span><br><span class="line">obj2.a.b &#x3D; 3;</span><br><span class="line">console.log(obj1.a.b); &#x2F;&#x2F; 3</span><br><span class="line">console.log(obj2.a.b); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><h4 id="2-3-递归实现深拷贝"><a href="#2-3-递归实现深拷贝" class="headerlink" title="2.3 递归实现深拷贝"></a>2.3 递归实现深拷贝</h4><h4 id="2-4-jquery实现深拷贝"><a href="#2-4-jquery实现深拷贝" class="headerlink" title="2.4 jquery实现深拷贝"></a>2.4 jquery实现深拷贝</h4><p>jquery 提供一个$.extend可以用来做深拷贝；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var $ &#x3D; require(&#39;jquery&#39;);</span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: &#123;</span><br><span class="line">     f: &#123;</span><br><span class="line">       g: 1</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 &#x3D; $.extend(true, &#123;&#125;, obj1);</span><br><span class="line">console.log(obj1.b.f &#x3D;&#x3D;&#x3D; obj2.b.f);  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><h1 id="数组拷贝方法"><a href="#数组拷贝方法" class="headerlink" title="数组拷贝方法"></a>数组拷贝方法</h1><p>注意：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p><h4 id="1-扩展运算符（浅拷贝）"><a href="#1-扩展运算符（浅拷贝）" class="headerlink" title="1. 扩展运算符（浅拷贝）"></a>1. 扩展运算符（浅拷贝）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; [...numbers];</span><br><span class="line">这个方法不能有效的拷贝多维数组。数组&#x2F;对象值的拷贝是通过引用而不是值复制。</span><br><span class="line">&#x2F;&#x2F; numbersCopy.push(4);</span><br><span class="line">console.log(numbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] and [1, 2, 3, 4]</span><br><span class="line">&#x2F;&#x2F; 只修改了我们希望修改的，原数组不受影响</span><br><span class="line">&#x2F;&#x2F; nestedNumbers &#x3D; [[1], [2]];</span><br><span class="line">numbersCopy &#x3D; [...nestedNumbers];</span><br><span class="line">numbersCopy[0].push(300);</span><br><span class="line">console.log(nestedNumbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; 由于公用引用，所以两个数组都被修改了，这是我们不希望的</span><br></pre></td></tr></table></figure><h4 id="2-for-循环、while-循环（浅拷贝）"><a href="#2-for-循环、while-循环（浅拷贝）" class="headerlink" title="2. for()循环、while()循环（浅拷贝）"></a>2. for()循环、while()循环（浅拷贝）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; [];</span><br><span class="line">for (i &#x3D; 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line"> numbersCopy[i] &#x3D; numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">这个方法不能有效的拷贝多维数组。因为我们使用的是&#x3D;运算符，它在处理数组&#x2F;对象值的拷贝时通过引用而不是值复制。</span><br><span class="line">&#x2F;&#x2F; numbersCopy.push(4);</span><br><span class="line">console.log(numbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3] and [1, 2, 3, 4]</span><br><span class="line">&#x2F;&#x2F; nestedNumbers &#x3D; [[1], [2]];</span><br><span class="line">numbersCopy &#x3D; [];</span><br><span class="line">for (i &#x3D; 0; i &lt; nestedNumbers.length; i++) &#123;</span><br><span class="line"> numbersCopy[i] &#x3D; nestedNumbers[i];</span><br><span class="line">&#125;</span><br><span class="line">numbersCopy[0].push(300);</span><br><span class="line">console.log(nestedNumbers, numbersCopy);</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; [[1, 300], [2]]</span><br><span class="line">&#x2F;&#x2F; 由于公用引用，所以两个数组都被修改了，这是我们不希望的</span><br></pre></td></tr></table></figure><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while()循环"></a>while()循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; [];</span><br><span class="line">i &#x3D; -1;</span><br><span class="line">while (++i &lt; numbers.length) &#123;</span><br><span class="line"> numbersCopy[i] &#x3D; numbers[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Array-map（浅拷贝）"><a href="#3-Array-map（浅拷贝）" class="headerlink" title="3. Array.map（浅拷贝）"></a>3. Array.map（浅拷贝）</h4><p>上面的for和while都是很“古老”的方式，让我们继续回到当前，我们会发现map方法。map源于数学，是将一个集合转换成另一种集合，同时保留结构的概念。<br>在英语中，它意味着Array.map 每次返回相同长度的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">double &#x3D; (x) &#x3D;&gt; x * 2;</span><br><span class="line">numbers.map(double);</span><br></pre></td></tr></table></figure><p>当我们使用map方法时，需要给出一个callback函数用于处理当前的数组，并返回一个新的数组元素。<br>和拷贝数组有什么关系呢？<br>当我们想要复制一个数组的时候，只需要在map的callback函数中直接返回原数组的元素即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; numbers.map((x) &#x3D;&gt; x);</span><br></pre></td></tr></table></figure><p>如果你想更数学化一点，(x) =&gt; x叫做恒等式。它返回给定的任何参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">identity &#x3D; (x) &#x3D;&gt; x;</span><br><span class="line">numbers.map(identity);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>同样的，处理对象和数组的时候是引用而不是值复制。</p><h4 id="4-Array-filter（浅拷贝）"><a href="#4-Array-filter（浅拷贝）" class="headerlink" title="4. Array.filter（浅拷贝）"></a>4. Array.filter（浅拷贝）</h4><p>Array.filter方法同样会返回一个新数组，但是并不一定是返回同样长度的，这和我们的过滤条件有关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].filter((x) &#x3D;&gt; x % 2 &#x3D;&#x3D;&#x3D; 0)</span><br><span class="line">&#x2F;&#x2F; [2]</span><br></pre></td></tr></table></figure><p>当我们的过滤条件总是true时，就可以用来实现拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; numbers.filter(() &#x3D;&gt; true);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>同样的，处理对象和数组的时候是引用而不是值复制。</p><h4 id="5-Array-reduce（浅拷贝）"><a href="#5-Array-reduce（浅拷贝）" class="headerlink" title="5. Array.reduce（浅拷贝）"></a>5. Array.reduce（浅拷贝）</h4><p>其实用reduce来拷贝数组并没有展示出它的实际功能，但是我们还是要将其能够拷贝数组的能力说一下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; numbers.reduce((newArray, element) &#x3D;&gt; &#123;</span><br><span class="line"> newArray.push(element);</span><br><span class="line"> return newArray;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数，将其结果汇总为单个返回值。<br>上面我们的例子中初始值是一个空数组，我们在遍历原数组的时候来填充这个空数组。该数组必须要从下一个迭代函数的执行后被返回出来。<br>同样的，处理对象和数组的时候是引用而不是值复制。</p><h4 id="6-Array-slice（浅拷贝）"><a href="#6-Array-slice（浅拷贝）" class="headerlink" title="6. Array.slice（浅拷贝）"></a>6. Array.slice（浅拷贝）</h4><p>slice 方法根据我们指定的start、end的index从原数组中返回一个浅拷贝的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5].slice(0, 3);</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">&#x2F;&#x2F; Starts at index 0, stops at index 3</span><br><span class="line">&#x2F;&#x2F; 当不给定参数时，就返回了原数组的拷贝</span><br><span class="line">numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">numbersCopy &#x3D; numbers.slice();</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>同样的，处理对象和数组的时候是引用而不是值复制。</p><h4 id="7-JSON-parse-JSON-stringify-object-（深拷贝）"><a href="#7-JSON-parse-JSON-stringify-object-（深拷贝）" class="headerlink" title="7. JSON.parse(JSON.stringify(object))（深拷贝）"></a>7. JSON.parse(JSON.stringify(object))（深拷贝）</h4><h4 id="8、Array-concat（浅拷贝）"><a href="#8、Array-concat（浅拷贝）" class="headerlink" title="8、Array.concat（浅拷贝）"></a>8、Array.concat（浅拷贝）</h4><p>concat将数组与值或其他数组进行组合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].concat(4); &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line">[1, 2, 3].concat([4, 5]); &#x2F;&#x2F; [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>如果我们不指定参数或者提供一个空数组作为参数，就可以进行浅拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].concat(); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">[1, 2, 3].concat([]); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>同样的，处理对象和数组的时候是引用而不是值复制。</p><h4 id="9、Array-from（浅拷贝）"><a href="#9、Array-from（浅拷贝）" class="headerlink" title="9、Array.from（浅拷贝）"></a>9、Array.from（浅拷贝）</h4><p>可以将任何可迭代对象转换为数组。给一个数组返回一个浅拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(Array.from(&#39;foo&#39;))</span><br><span class="line">&#x2F;&#x2F; [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span><br><span class="line">numbers &#x3D; [1, 2, 3];</span><br><span class="line">numbersCopy &#x3D; Array.from(numbers)</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure><p>同样的，处理对象和数组的时候是引用而不是值复制。</p><h1 id="笔记参考链接："><a href="#笔记参考链接：" class="headerlink" title="笔记参考链接："></a>笔记参考链接：</h1><ol><li><a href="https://www.cnblogs.com/chengxs/p/10788442.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxs/p/10788442.html</a></li><li><a href="https://blog.csdn.net/luoandhuang/article/details/90258010" target="_blank" rel="noopener">https://blog.csdn.net/luoandhuang/article/details/90258010</a></li><li><a href="https://www.jb51.net/article/160063.htm" target="_blank" rel="noopener">https://www.jb51.net/article/160063.htm</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS中scrollTop()的浏览器兼容问题</title>
      <link href="/2019/12/03/JS%E4%B8%ADscrollTop()%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2019/12/03/JS%E4%B8%ADscrollTop()%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在写js获取页面滚动条距顶部的距离时，遇到了浏览器兼容的问题，尝试使用如下代码后解决了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var top &#x3D; window.pageYOffset</span><br><span class="line">        || document.documentElement.scrollTop</span><br><span class="line">        || document.body.scrollTop</span><br><span class="line">        || 0;</span><br></pre></td></tr></table></figure><p>各浏览器下scrollTop的差异总结如下：</p><h3 id="IE6-7-8-9-10："><a href="#IE6-7-8-9-10：" class="headerlink" title="IE6/7/8/9/10："></a>IE6/7/8/9/10：</h3><p>对于没有doctype声明的页面里可以使用  document.body.scrollTop 来获取 scrollTop高度；<br>对于有doctype声明的页面则可以使用 document.documentElement.scrollTop；</p><h3 id="Safari"><a href="#Safari" class="headerlink" title="Safari:"></a>Safari:</h3><p>safari 比较特别，有自己获取scrollTop的函数：window.pageYOffset；</p><h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox:"></a>Firefox:</h3><p>document.documentElement.scrollTop；</p><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>document.documentElement.scrollTop</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5新特性</title>
      <link href="/2019/11/30/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/11/30/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="HEML5音频"><a href="#HEML5音频" class="headerlink" title="HEML5音频"></a>HEML5音频</h3><ul><li>control属性供添加播放、暂停和音量控件</li><li>标签：<audio> 定义声音、<source> 规定多媒体资源，可以是多个<br>示例：<br>第一种方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src&#x3D;&quot;raw&#x2F;3.mp4&quot; controls&#x3D;&quot;controls&quot;&gt;浏览器不支持&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure>第二种方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio controls&#x3D;&quot;controls&quot;&gt;</span><br><span class="line">&lt;source src&#x3D;&quot;raw&#x2F;3.mp4&quot;&gt;</span><br><span class="line">&lt;source src&#x3D;&quot;raw&#x2F;3.ogg&quot;&gt;</span><br><span class="line">&lt;&#x2F;audio&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTML视频"><a href="#HTML视频" class="headerlink" title="HTML视频"></a>HTML视频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;video controls&#x3D;&quot;controls&quot; height&#x3D;&quot;300px&quot; width&#x3D;&quot;300px&quot;&gt;</span><br><span class="line">&lt;source src&#x3D;&quot;raw&#x2F;3.mp4&quot;&gt;</span><br><span class="line">&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure><h3 id="HTML拖放"><a href="#HTML拖放" class="headerlink" title="HTML拖放"></a>HTML拖放</h3><ul><li>设置元素为可拖放：draggable=”true”</li><li>拖放什么：ondragstart和setData()</li><li>放到何处：ondragover</li><li>进行放置：ondrop</li></ul><h3 id="HTML画布"><a href="#HTML画布" class="headerlink" title="HTML画布"></a>HTML画布</h3><p>canvas</p><h3 id="HTML-SVG"><a href="#HTML-SVG" class="headerlink" title="HTML SVG"></a>HTML SVG</h3><p>什么是SVG？</p><ul><li>SVG指可伸缩矢量图形（Scalable Vector Graphics）</li><li>SVG用于定义用于网络的基于矢量的图形</li><li>SVG使用XML格式定义图形</li><li>SVG图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG是万维网联盟的标准</li></ul><p>SVG的优势</p><ul><li>SVG图像可通过文本编辑器来创建和修改</li><li>SVG图像可被搜索、索引、脚本化或压缩</li></ul><h3 id="HTML地理定位"><a href="#HTML地理定位" class="headerlink" title="HTML地理定位"></a>HTML地理定位</h3><h3 id="HTML拖放-1"><a href="#HTML拖放-1" class="headerlink" title="HTML拖放"></a>HTML拖放</h3><h3 id="HTML画布-1"><a href="#HTML画布-1" class="headerlink" title="HTML画布"></a>HTML画布</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2019/11/30/CSS%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/30/CSS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ul><li>通用选择器 *{margin:0px;}</li><li>标签选择器 p{margin:0px;}</li><li>类选择器 .box{margin:0px;}</li><li>id选择器 #title{margin:0px;}</li></ul><h3 id="尺寸样式属性"><a href="#尺寸样式属性" class="headerlink" title="尺寸样式属性"></a>尺寸样式属性</h3><ul><li>height</li><li>weight<br><span></span>不能设置宽度和高度，因为span标签是一个行内元素。只有块级元素（div）才可以设置宽高。</li></ul><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><ul><li>color</li><li>text-align ：left、right、center 文本的水平对其方向</li><li>text-decoration： none、underline（下划线）、overline（上划线）、line-through（删除线）</li><li>text-transform：capitalize（首字母大写）、uppercase、lowercase</li><li>line-height：行高</li><li>text-indent：首行缩进，允许负值</li><li>letter-spacing：字符间距</li><li>word-spacing：单词间距</li></ul><a id="more"></a><h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><ul><li>font-style：normal、italic（斜体)</li><li>font-weight：normal、bold（加粗)</li><li>font-size</li><li>font-family：”微软雅黑”、”宋体”</li></ul><h3 id="复合元素选择器"><a href="#复合元素选择器" class="headerlink" title="复合元素选择器"></a>复合元素选择器</h3><ul><li>多元素选择器 p, h1, h2{margin:0px;}</li><li>后代元素选择器 E F{margin:0px;} </li><li>子元素选择器 E &gt; F{margin:0px;}</li><li>相邻元素选择器 E + F{margin:0px;}</li></ul><h3 id="列表样式属性"><a href="#列表样式属性" class="headerlink" title="列表样式属性"></a>列表样式属性</h3><ul><li>line-style-type：none、disc（实心圆）、square（实心小方块）、circle（空心圆）</li><li>line-style-position：inside、outside</li><li>line-style-image：url(./images/img.jpg);</li></ul><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>给超级链接的不同状态设置样式</p><ul><li>:link</li><li>:visited</li><li>:hover</li><li>:active</li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul><li>h1[attr]{….}</li><li>h1[attr=”center”]{….}</li><li>font[attr^=”#ff”] 匹配元素中attr属性以指定值开头的所有元素</li><li>font[attr$=”#ff”] 匹配元素中attr属性以指定值结尾的所有元素</li><li>font[attr*=”#ff”] 匹配元素中attr属性包含指定值的所有元素</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ol><li>外层元素身上的样式会被内层元素继承；</li><li>当内层元素与外层元素身上的样式相同时，外层元素的样式会被内层元素覆盖；</li><li>只有文本和字体样式属性能够被继承。</li></ol><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>行内样式 &gt; Id选择器 &gt; 类选择器 &gt; 标签选择器</p><ul><li>行内样式 1000</li><li>Id选择器 100</li><li>类选择器 10</li><li>标签选择器 1</li></ul><h3 id="important属性"><a href="#important属性" class="headerlink" title="!important属性"></a>!important属性</h3><ul><li>主要用来提升属性权重值，将属性权重值提升至无穷大</li><li>提升的是属性的权重，不是选择器的权重</li><li>用法 color：#f00 !important;</li></ul><h3 id="一个标签内可以携带多个类名"><a href="#一个标签内可以携带多个类名" class="headerlink" title="一个标签内可以携带多个类名"></a>一个标签内可以携带多个类名</h3><ul><li>举例：<div class="s1 s2 s3"></div></li></ul><h3 id="背景样式属性"><a href="#背景样式属性" class="headerlink" title="背景样式属性"></a>背景样式属性</h3><ul><li>backgroun-color 给元素设置背景颜色，前提是元素要么有宽高，要么有内容</li><li>background-image：url(./images/img.jpg); 设置背景图片，默认平铺</li><li>background-repeat : repeat、repeat-x（水平方向）、repeat-y（垂直方向）、no-repeat</li><li>background-position ：水平位置（left、center、right、固定值、百分比）垂直位置（ top、center、bottom、固定值、百分比）</li><li>background-attachment：fixed（固定）、scroll（滚动）</li></ul><h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><ul><li>空白折叠现象 内容放在一行就没有空白了</li><li>高矮不齐，底部对齐</li></ul><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>让多个元素排在同一行，并设置宽高<br>在标准文档流中元素只有两种：块级元素和行内元素</p><ul><li>浮动元素遇到父元素边框线就停止移动</li><li>浮动元素层级比标准文档流里的而元素层级高，会将其覆盖</li><li>浮动元素遇到上一个浮动元素就停止移动</li><li>父元素不会包裹浮动元素，浮动元素会盖住边框</li><li>span元素浮动后可以设置宽高</li></ul><p>PS：用通用选择器去除所有标签中的默认内填充和外边距：*{ padding : 0px; margin : 0px;}</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>给浮动元素的父元素设定一个高度</li><li>clear属性  clear：left；清除左浮动  clear：right；清除右浮动  clear：both；两者都清楚<br> 在最后一个浮动元素的下面新建一个空白 .p{clear:both;}</li><li>给父元素设置一个overflow : hidden；属性  原意是用来将溢出的部分进行隐藏，也可用于清除浮动</li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>CSS中一个盒子的组成部分：</p><ul><li>内容：content</li><li>内填充：padding 上右下左、上(左右)下、(上下) (左右) <ul><li>善于使用父元素的padding而不要使用子元素的margin</li></ul></li><li>边框：border</li><li>外边距：margin <ul><li>在标准文档流中，竖直方向margin值不会叠加，取较大值</li><li>水平方向没有margin塌陷现象</li><li>浮动元素没有margin塌陷现象</li></ul></li></ul><p>如果元素未设置固定的宽度（width），则它的宽度会占据父元素100%宽度</p><h3 id="margin居中"><a href="#margin居中" class="headerlink" title="margin居中"></a>margin居中</h3><ul><li>margin-left : auto; margin-right : auto; 使用margin实现水平居中时，元素必须设置了固定的宽度</li><li>只有块元素才能实现水平居中，行内元素不可以，因为行内元素无法设置宽度</li><li>只有标准文档流中的盒子才可以使用margin实现水平居中</li><li>margin属性是用来实现盒子水平居中，而不是文本水平居中；text-align才是实现文本的对齐</li></ul><h3 id="border属性"><a href="#border属性" class="headerlink" title="border属性"></a>border属性</h3><ul><li>border：1px  solid  #f00；颜色不写默认黑色，其余两个属性必须写，不写就不显示边框</li><li>线型：dotted（点状线）、dashed（虚线）、solid、double、groove、ridge、inset（输入框）、outset</li><li>方向：border-top、border-bottom、border-left、border-right：1px  solid  #f00；可分别设置对应边框线</li></ul><h3 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h3><p>用来进行行内元素与块级元素之间相互转换，将隐藏的元素显示或将显示的元素隐藏。</p><ul><li>display：block；将行内元素转换为块级元素</li><li>display：inline；将块级元素转换为行内元素</li><li>display：none;  将一个显示的元素隐藏</li><li>display：block;  将一个隐藏的元素显示 后两个主要是JS使用</li></ul><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>在使用定位属性时，一定要配合定位的坐标来使用！（left、right、top、bottom）</p><ul><li>position:fixed; 相对于浏览器窗口定位<ul><li>固定定位元素脱离了标准文档流</li><li>固定定位元素的层级比标准文档流的元素要高，会将其盖住</li><li>固定定位元素不再占用空间</li><li>固定定位元素不会随着浏览器滚动而滚动</li><li>固定定位可实现页面中返回顶部按钮以及导航栏</li></ul></li><li>position:relative; <ul><li>相对定位元素没有脱离标准文档流</li><li>相对定位元素若未设置定位坐标，则其还在原位</li><li>相对定位元素设置了定位坐标后，会在原处留意下一个坑，以这个坑为基准进行移动</li><li>相对定位元素会将标准文档流中的元素压盖住</li><li>相对定位元素一般很少单独使用，一般是为了配合“绝对定位”元素使用的</li></ul></li><li>position:absolute; <ul><li>绝对定位元素脱离了标准文档流</li><li>绝对定位元素不再占用空间</li><li>绝对定位元素会压盖住标准文档流中的元素</li><li>绝对定位元素会相对于其祖先定位元素来进行定位，一般只会给其祖先定位元素设置相对定位元素，“子绝父相”</li></ul></li></ul><h3 id="z-index属性"><a href="#z-index属性" class="headerlink" title="z-index属性"></a>z-index属性</h3><ul><li>z-index表示谁压盖着谁，数值大的会压盖住数值小的</li><li>只有定位元素才有z-index值</li><li>z-index值没有单位，是一个正整数，默认0</li><li>若多个定位元素未设置z-index属性或z-index值一样，那么写在html后面的定位元素会压盖住前面的定位元素</li><li>可以给导航条设置一个较大的z-index值，这样在滚动过程中页面中其他元素都不会压盖住导航条</li></ul><h3 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h3><ul><li>E:first-child{}; 匹配第一个孩子</li><li>E:last-child{}; 匹配最后一个孩子</li><li>E:nth-child(n){}; 指定括号内n值，能够匹配到第n个孩子</li><li>E:nth-child(2n){} / E:nth-child(even){}; 匹配所有偶数的孩子</li><li>E:nth-child(2n+1){}; / E:nth-child(odd){}; 匹配所有奇数的孩子</li><li>E:only-child{}; 匹配有且仅有一个孩子的 </li></ul><h3 id="border-collapse"><a href="#border-collapse" class="headerlink" title="border-collapse"></a>border-collapse</h3><p>用来合并表格的边框线</p><ul><li>border-collapse:collapse;</li></ul><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><ul><li>E:first-letter{}; 操作当前元素中的第一个字</li><li>E:first-line{}; 操作当前元素中第一行文字</li><li>E::before{ content : “文字”; }; 在之前插入，在一个盒子内部的最前面</li><li>E::after{}; 在之后插入，在一个盒子内部的最后面</li></ul><h3 id="文本阴影"><a href="#文本阴影" class="headerlink" title="文本阴影"></a>文本阴影</h3><ul><li>text-shadow：水平阴影 垂直阴影 模糊的距离  阴影的颜色</li><li>水平阴影、垂直阴影必须写，其余可以省略</li><li>举例：text-shadow：3px 3px 3px #f00</li><li>可以设置多组阴影，用逗号分隔</li></ul><h3 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h3><ul><li>box-shadow：水平方向阴影  垂直方向阴影  模糊距离  阴影尺寸  阴影颜色  内/外阴影(inset/ouset)</li><li>水平阴影、垂直阴影必须写，其余可以省略</li><li>举例：box-shadow：3px 3px 3px 3px #f00 inset；</li><li>盒子阴影可设置多组，用逗号分隔</li></ul><h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><ul><li>border-radius：左上 右上 右下 左下；</li><li>举例：border-radius：2px 2px 2px 2px；</li><li>实现椭圆：圆角矩形的值为高度一半</li><li>实现圆形：当前元素高度宽度相同，圆角矩形值设置为宽高的一半</li></ul><h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><ul><li>rgba（红色，绿色，蓝色，透明度）</li><li>a：表示透明度 取值：0~1 0表示完全透明，1表示不透明</li><li>背景颜色透明：background-color : rgba(255,0,0,0.5);</li><li>文本颜色透明：color:rgba(255,255,255,0.3);</li><li>边框颜色透明：border:1px solid rgba(255,255,255,0.5);</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署遇到的错误</title>
      <link href="/2019/11/30/Hexo%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2019/11/30/Hexo%E9%83%A8%E7%BD%B2%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<hr><p>在执行如下命令将本地博客部署到GitHub上时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>遇到了如下错误：</p><p><img src="/images/hexo%E9%83%A8%E7%BD%B2%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.jpg" alt="hexo部署错误"></p><p>  试了很多办法都无法解决，最后还是备份了当前的本地博客文件，重新hexo init了一个博客<br>再重新进行博客配置，就能成功部署到GitHub上了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2019/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/11/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="6-4-TCP"><a href="#6-4-TCP" class="headerlink" title="6.4 TCP"></a>6.4 TCP</h1><hr><h3 id="6-4-1-TCP的特点及其目的"><a href="#6-4-1-TCP的特点及其目的" class="headerlink" title="6.4.1 TCP的特点及其目的"></a>6.4.1 TCP的特点及其目的</h3><p>&amp;nbps&amp;nbps为通过IP数据报实现可靠性传输<br>&amp;nbps&amp;nbpsTCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><h3 id="6-4-2-通过序列号（SEQ）与确认应答（ACK）提高可靠性"><a href="#6-4-2-通过序列号（SEQ）与确认应答（ACK）提高可靠性" class="headerlink" title="6.4.2 通过序列号（SEQ）与确认应答（ACK）提高可靠性"></a>6.4.2 通过序列号（SEQ）与确认应答（ACK）提高可靠性</h3><p>&amp;nbps&amp;nbps发送端数据到达接受主机时，接收端主机会返回ACK。<br>若收到ACK，说明数据已成功到达对端；反之，数据丢失的可能性很大。</p><h3 id="未收到ACK两种情况："><a href="#未收到ACK两种情况：" class="headerlink" title="未收到ACK两种情况："></a>未收到ACK两种情况：</h3><p>1、图<br>发送过程中丢包，发送端经过特定时间间隔重发数据。<br>2、图<br>接收端返回的ACK因网络拥堵等原因在传送途中丢失，发送端经过特定时间间隔重发数据。<br>3、在源主机重发数据后ACK才到达。</p><a id="more"></a><p>由于有以上情况的出现，对于目标主机来说，会反复收到相同的数据。而为了对上层应用提供可靠的传输，必须放弃重复的数据包。<br>为此引入序列号。<br>为发送数据每一个8位字节标上编号。<br>接收端查询接收数据TCP首部中序列号和数据的长度，将下一步应接受的序号作为ACK送回去。</p><p>图</p><h3 id="6-4-3-重发超时如何确定"><a href="#6-4-3-重发超时如何确定" class="headerlink" title="6.4.3 重发超时如何确定"></a>6.4.3 重发超时如何确定</h3><p>一般设置为6秒左右。</p><h3 id="6-4-4-连接管理"><a href="#6-4-4-连接管理" class="headerlink" title="6.4.4 连接管理"></a>6.4.4 连接管理</h3><p>图</p><p>TCP链接：三次握手<br>TCP断开：四次挥手</p><h3 id="6-4-5-TCP以段为单位发送数据"><a href="#6-4-5-TCP以段为单位发送数据" class="headerlink" title="6.4.5 TCP以段为单位发送数据"></a>6.4.5 TCP以段为单位发送数据</h3><p>两端主机在发出建立连接请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应的MSS大小。选择两者间较小值投入使用。</p><p>图</p><h3 id="6-4-6-利用窗口控制提高速度"><a href="#6-4-6-利用窗口控制提高速度" class="headerlink" title="6.4.6 利用窗口控制提高速度"></a>6.4.6 利用窗口控制提高速度</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
